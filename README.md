# online-theatre

Проект онлайн-кинотеатра.

# Дипломная часть проекта:
## Тема дипломного проекта: Сервис биллинга
### Схема архитектуры проекта
<img width="888" alt="image_2025-04-05_11-50-04" src="https://github.com/user-attachments/assets/371780ff-1936-4b98-b9f2-73dddf374452" />

### Описание
Сервис биллинга выполнен на базе ранее написаного проекта online-theatre. Выполнение задания подразумевает собой написание дополнительного сервиса биллинга в приложение.
Соответсвенно, запуск приложения необходимо осуществлять через compose.billing.yaml. Данный файл содержит в себе все контейнеры задействованные в исполнении сервиса.
Исходя из представленной и утвержденной архитекутуры были добавлены следующие сервисы:
- billing-service - Основной сервис биллинга. Исполнен на FastAPI. Сервис позволяет: получить доступ к админ-панели платежной системы, отправлять платежи на товары и услуги, возвращать средства за товары и услуги.
- billing-service-postgresql - PostgreSQL-контейнер. Необходим для сохранения записей о состоянии транзакций.
- billing-service-init - Сервис для инициализации суперпользователя в админ-панели.
- payment-service - Сервис для перенаправления пользователя на сайт платежной системы осуществления транзакции и уведомления его о статусе платежа.
- payment-redis - Redis-контейнер. Необходим для сохранения акуального состояния платежа и токенов авторизации пользователей.
- billing-rabbitmq - Брокер сообщения. Сохраняет в свою очередь уведомления о статусе платежей.
- worker-billing-notify - Воркер. Слушает очередь отправляет поступившие сообщения на сервис уведомлений.

Сервис биллинга был интегрирован в следующие ранее написанные сервисы приложения:
- short-link-service - Сервис коротких ссылок. Возвращает короткие ссылки для авторизации и подтверждаения транзакций пользователей.
- notification-service - Сервис уведомлений. Используется для оповещения пользователя о состоянии транзакции.
- auth-service - Сервис авторизации. Используется для валидации пользователей использующих сервис (не авторизованным пользователям сервиса биллинга не доступен)
- jeager - Сервис Jeager. Для трассировки.

# НЕ Дипломная часть проекта
## Запуск проекта в Docker Compose

* _compose.yaml_ &mdash; запуск основного приложения с данными из _сompose/postgresql/database_dump.sql_.
* _compose.faker.yaml_ &mdash; запуск основного приложения со сгенерированными данными из faker (генерирует
200000 фильмов).

### Запуск в режиме продакшн

```shell
$ ./run_server.sh
```

### Запуск в режиме для разработчиков (с использованием Docker Compose Watch)

```shell
$ ./run_server.sh dev
```

## Запуск тестов в Docker Compose

### Стандартный запуск тестов

```shell
$ ./run_tests.sh
```

### Запуск тестов с указанием версии Python

```shell
$ PYTHON_VERSION=3.12 ./run_tests.sh
```

### Запуск тестов с использованием Docker Compose Watch

В одном окне терминала стартуем сервисы в watch mode:

```shell
$ ./run_tests.sh watch
```

Когда все контейнеры с сервисами запустятся, в другом окне терминала выполняем уже сами тесты:

```shell
$ ./run_tests.sh tests
```

## Статический анализ кода

### Стандартный запуск в Docker Compose

В качестве первого параметра скрипта необходимо передать название вида статического анализа.
Если второй параметр не задан, то соответствующая команда будет запущена в контейнере каждого
сервиса из Compose file, в котором она поддерживается:

```shell
$ ./run_lint.sh mypy
```

Доступны следующие названия команд статического анализа:
* `mypy`
* `ruff`

В качестве второго параметра можно указать название конкретного сервиса, код которого необходимо
проанализировать:

```shell
$ ./run_lint.sh mypy movies
```

Результаты статического анализа для каждого сервиса сохраняются в соответствующий том Docker,
который монтируется на хост-систему в директорию _.lint_.

### Запуск с использованием Docker Compose Watch

В одном окне терминала:

```shell
$ ./run_lint.sh watch
```

В другом окне терминала:

```shell
$ ./run_lint.sh watch mypy
```

Также возможен статический анализ кода конкретного сервиса:

```shell
$ ./run_lint.sh watch mypy movies
```

### Интеграция с Sentry

Для интеграции было принято решение использовать sentry.io.

    1. Зарегистрируйте аккаунт на sentry.io (если у вас его еще нет).
    2. Во вкладке Projects создайте новый проект, выбрав язык Python.
    3. Перейдите в Settings созданного проекта.
    4. В разделе Client Keys (DSN) скопируйте значение DSN.
    5. Добавьте это значение в файл .env:
        SENTRY_DSN=<ваш DSN>

После этого ошибки в приложении будут автоматически отправляться в Sentry.


# Тестирование по выбору хранилища UGC
### Результаты тестирования по выбору хранилища UGC представлены в папке test_database

# Тестирование по выбору хранилища PostgreSQL и MongoDB
### Результаты тестирования по выбору хранилища PostgreSQL и MongoDB представлены в папке test_database

# Над проектом работали:
## Шаров Илья (ЯП: @i.sh.8520, github: @ishar8520) - тимлид
## Опанчук Артем (ЯП: @artyom.opanchuk, github: @linux-warrior) - разработчик
## Мария Пирогова (ЯП: @miss.yefimenko, github: @Maliarda) - разработчик
## Лашков Максим (ЯП: @maxim.lashkov, github: @maximlashkov) - разработчик
## Максим Павленков (ЯП: @edmpeople0, github: @maks-pavlenkov) - разработчик
